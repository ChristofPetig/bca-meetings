# September 27 project call

**See the [instructions](../README.md) for details on how to attend**

## Agenda
1. Opening, welcome and roll call
    1. Note: meeting notes linked in the invite.
    1. Please help add your name to the meeting notes.
    1. Please help take notes.
    1. Thanks!
1. Announcements
    1. _Submit a PR to add your announcement here_
1. Other agenda items
    1. (15 min) akashin & nagisa presenting zkASM backend to get feedback from the team. You can get more context by reading a [Zulip Thread](https://bytecodealliance.zulipchat.com/#narrow/stream/217117-cranelift/topic/zkASM.20backend) and a [Hackmd document](https://hackmd.io/DK6S9vsbQ9GAmBJEOIwh4w?view).
    2. _Submit a PR to add your item here_

## Notes

### Attendees

- cfallin
- alexcrichton
- fitzgen
- avanhatt
- afonso360
- abrown
- Andrei Kashin
- nagisa
- Viktor Makouski

### Notes

- Andrei: zkASM presentation
  - [slides](https://docs.google.com/presentation/d/1y4_xU5igjy-dOaq4_MtAC7lVc9mUJHTEEB9HW94tb9M/edit#slide=id.g1c807bc46ad_0_0)
  - looking into zero-knowledge proofs for verified execution
  - provide a proof of program execution alongside the result
  - have a prototype Cranelift backend that generates zkAsm

  - cfallin: main concern: so different from other ISAs: every other supported
    backend we can test with qemu, runs Linux, supports ELF binaries, allows us
    to debug with gdb, can more or less use the shared ABI code, unwind code,
    ...
    - likely to be a maintenance burden for us in the short term to have this
      as a backend when adding new features like tail calls, or exception
      unwind support, or ...

  - cfallin: whole platform or just Cranelift? how do you run Wasm test suite?
    - Andrei: why do we need Wasmtime?
    - fitzgen: need the Wasm runtime for e.g. memory accesses, ...
    - fitzgen: libcalls as well (e.g. memory growth)
    - jameysharp: you use cranelift-wasm already, but not wasmtime-cranelift
    - abrown: you indeed need a runtime; but not impossible
    - cfallin: indeed; but we wouldn't upstream that
  - fitzgen: alternative: out-of-tree consumer of CLIF?
  - or make all the traits public so that one can plug in an external backend?
    - indeed, seems it could be an option
    - jameysharp: we've talked before about this, just no one has done the work
      - integration of ISLE build-time stuff, ...
      - other crates depending on buildscript-generated ISLE
  - conclusion: allow out-of-tree backends; please feel free to file an issue,
    note things that need to change to allow this

- fitzgen: interesting perf investigation
  ([link](https://github.com/bytecodealliance/wasmtime/issues/7085)) 
  - Cranelift-generated code 5x slower than LLVM-generated code
  - first thought: loading constant from pool in inner loop?
  - thought about loop alignment, code size, ...
  - compare to code generated by native LLVM: exactly the same operations,
    slightly tighter VEX encoding
    - made a change to avoid xmm8-15 when possible (prefer lower registers) to
      use smaller encoding -- upstreamed
  - eventually: integer to float conversion instruction has a dependency on
    original register (preserves upper half of register) -> false dep
    - creates a dependence between loop iterations
    - LLVM zeroes input register outside of loop
    - our solution will be like SpiderMonkey's: always zero input register first
    - abrown: wanted to use VTune to analyze; unfortunately not wired up
      correctly with Wasmtime; will see if we can do this
    - Simonas: tried llvm-mca to analyze?
      - will print "execution plan" -- useful tool
      - abrown: indeed very useful; difference is it's static "expected" plan
        vs. VTune actual dynamically-collected data
    - cfallin: audit other unary ops that may have hardcoded same-input-reg?
      - this came about because of a simplification: actual inst takes an input
        and produces an output, replacing low 64 bits; we hardcoded that input
        to be same as output because we don't care about the not-replaced bits
      - this collapsing of binary op into unary op is correct (if we don't care
        about upper bits) but slow; have we done it elsewhere?
